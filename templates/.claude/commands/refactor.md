# リファクタリングコマンド

コードの複雑度を分析し、SOLID原則に基づいてリファクタリングを実行します。

## 使い方

```
/refactor <対象ファイルや機能の説明>
```

## プロンプト

以下の手順でリファクタリングを実施してください：

### 1. 対象の分析

`$1` で指定された対象コードを分析します：

- ファイルの構造・シンボルを概観
- 関数・クラスの責務を確認
- 依存関係を把握

### 2. 複雑度の評価

以下の観点で問題を特定します：

| 観点 | チェック内容 |
|------|------------|
| **関数の長さ** | 30行を超える関数 |
| **ネストの深さ** | 3段以上のネスト |
| **パラメータ数** | 4個以上のパラメータ |
| **重複コード** | 類似ロジックの繰り返し |
| **神クラス** | 過大な責務を持つクラス |
| **密結合** | 過剰な依存関係 |

### 3. SOLID 原則による評価

- **S** (単一責任): 各クラス・関数は1つの責務のみか
- **O** (開放閉鎖): 拡張に開き、修正に閉じているか
- **L** (リスコフ置換): サブタイプは親タイプの契約を守っているか
- **I** (インターフェース分離): 不要な依存を強制していないか
- **D** (依存性逆転): 抽象に依存しているか

### 4. リファクタリング計画

改善案を提示します：

```markdown
## リファクタリング計画

### 改善項目
1. **項目名** — 概要
   - 現状: [問題の説明]
   - 改善: [リファクタリング内容]
   - 影響: [影響するファイル]

### 実行順序
1. [手順1] — 理由
2. [手順2] — 理由
```

### 5. 実行と検証

ユーザーの承認後にリファクタリングを実行します：

- 各ステップで既存テストが通過することを確認
- 振る舞いが変わっていないことを検証
- 必要に応じてテストを追加

### 6. 結果レポート

```markdown
## リファクタリング結果

### 変更サマリー
- 変更ファイル数: N
- 追加行数 / 削除行数

### 改善指標
| 指標 | Before | After |
|------|--------|-------|
| 最大関数行数 | N | N |
| 最大ネスト深度 | N | N |
| 重複コード箇所 | N | N |

### テスト結果
- [ ] 既存テスト全件通過
- [ ] 新規テスト追加済み
```

---

**更新日**: 2025-10-20
